/**
 * @author Darius Haș
 * @group 30432
 *
 * Specificațiile problemei, ex: Comparison between the Bottom Up and Top down building Heap aproaches
 *
 * Interpretarea personală despre complexitate (timp și spațiu), despre cazurile de testare (favorabil,
 * mediu-statistic si nefavorabil):
 * n-size of the array
 * QuickSort vs HeapSort in average case: HeapSort takes the Random array generated and applies heapify to it which takes O(n log n) time and then,
 * in a loop, swaps the last and the first elements and then makes a heap from the remaining elements ignoring the last one (which is 
 * already in place regarding the sorting) and decreasing the size at each step with 1. So the complexity of HeapSort is O(n log n).
 * QuickSort also has a complexity of O(n log n) but as we observe from the charts it is more efficient than HeapSort because of the multiplicity constant
 * of the heapsort that is quite big. 
 * Best Case QuickSort: it can be generated by using a sorted array and always choosing the middle element as pivot at each call, in that way partitioning
 * the elements into two equal(or almost equal) parts at each recursive call.If we do it this way and we observe the charts we are going to see that 
 * it has a complexity of O(n log n).
 * Average Case QuickSort: it is also O(n log n) and it is actually pretty close to the best case scenario.
 * Worst Case QuickSort: it can be generated by using a sorted array(either ascending or descending) and choosing the last element as pivot.In that way,
 * we are going to partition the elements in two parts: one containing one element and the other containing the remaining ones at each recursive call.
 * We can see that the complexity is O(n^2) but if we were to apply a random choice of the pivot we can easily avoid this case.
 */
#include <iostream>
#include <conio.h>
#include <stdlib.h>  
#include <time.h>  
#include "Profiler.h"
#define MAX_VALUE 10000
using namespace std;
Profiler profiler("Lab3");
void heapifyBottomUp(int a[], int n,int x, int index, const char* name)
{
	profiler.countOperation(name, x, 0);
	int max_value, aux;
	if ((2 * index + 1) < n && a[2 * index + 1] > a[index])
	{
		max_value = 2 * index + 1;
		profiler.countOperation(name, x, 1);
	}
	else {
		if (2 * index + 1 < n)
			profiler.countOperation(name, x, 1);
		max_value = index;
	}

	if ((2 * index + 2) < n && a[2 * index + 2] > a[max_value])
	{
		max_value = 2 * index + 2;
		profiler.countOperation(name, x, 1);
	}
	if (2 * index + 2 < n)
		profiler.countOperation(name, x, 1);
	if (max_value != index)
	{
		profiler.countOperation(name, x, 3);
		swap(a[index], a[max_value]);
		heapifyBottomUp(a, n, x, max_value, name);
	}

}

void bottomUpBuildHeap(int a[],int x, int n, const char* name)
{
	int i;
	for (i = n / 2; i >= 0; i--)
		heapifyBottomUp(a, n, x, i, name);
}

void heapSort(int a[], int n, const char* name)
{
	int x = n;
	for (int i = n - 1; i > 0; i--)
	{
		profiler.countOperation(name, x, 3);
		int aux;
		aux = a[i];
		a[i] = a[0];
		a[0] = aux;
		heapifyBottomUp(a, --n,x, 0, name);
	}

}



int partition(int a[],int n, int first, int last,const char* name)
{
	profiler.countOperation(name, n, 0);
	int x = a[last];
	profiler.countOperation(name, n, 1);

	int i = first - 1;
	for (int j = first; j <= last - 1; j++)
	{
		profiler.countOperation(name, n, 1);
		if (a[j] < x)
		{
			profiler.countOperation(name, n, 3);
			i++;
			swap(a[i], a[j]);
		}
			
	}
		swap(a[i + 1], a[last]);
		profiler.countOperation(name, n, 3);
		return i + 1;

}

int randomPartition(int a[],int n, int first, int last,const char* name)
{
	int i = rand() % (last - first + 1) + first;
	profiler.countOperation(name, n, 3);
	swap(a[last], a[i]);
	return partition(a, n,first, last,name);
}

int partitionBest(int a[], int n, int first, int last, const char* name)
{
	profiler.countOperation(name, n, 3);
	swap( a[last], a[(last + first) / 2]);
	return partition(a, n, first, last, name);
}

void quicksort(int a[], int n,int first, int last,const char* name)
{
	int q;
	profiler.countOperation(name, n, 0);
	if (first < last)
	{
		q = partition(a,n, first, last,name);
		quicksort(a, n,first, q-1,name);
		quicksort(a,n, q + 1, last,name);
	}
}

void quicksortRandom(int a[], int n, int first, int last, const char* name)
{
	int q;
	profiler.countOperation(name, n, 0);
	if (first < last)
	{
		q = randomPartition(a, n, first, last, name);
		quicksortRandom(a, n, first, q - 1, name);
		quicksortRandom(a, n, q + 1, last, name);
	}
}

void quicksortBest(int a[], int n, int first, int last, const char* name)
{
	int q;
	profiler.countOperation(name, n, 0);
	if (first < last)
	{
		q = partitionBest(a, n, first, last, name);
		quicksortBest(a, n, first, q - 1, name);
		quicksortBest(a, n, q + 1, last, name);
	}
}

int select(int a[],int n, int first, int last, int i,const char* name)
{ 
	if (first == last)
		return a[first];
	int pivot = randomPartition(a,n, first, last,name);
	if (i == pivot)
		return a[i];
	else
		if (i < pivot)
			return select(a,n, first, pivot - 1, i,name);
		else
			return select(a,n, pivot + 1, last, i,name);


}

void quickSelect(int a[],int n, int first, int last,const char* name)
{
	
	if (first < last)
	{
		int median = (last - first+1) / 2 + first;
		select(a,n, first, last, median,name);
		quickSelect(a, n,first, median-1,name);
		quickSelect(a, n,median , last,name);
	}
}

void exemplifyCorrectness() {
	int a[10],i,v[10];
	FillRandomArray(a, 10, 0, 100, true, 0);
	for (i = 0; i < 10; i++)
		v[i] = a[i];
	cout << "This is a random array:"<<endl;
	for (i = 0; i < 10; i++)
		cout << a[i] << " ";
	cout << endl;
	quicksort(a, 10, 0, 9, "");
	cout << "This is The array sorted with quicksort:" << endl;
	for (i = 0; i < 10; i++)
		cout << a[i] << " ";
	cout << endl;

	cout <<endl<< "This is the same random array:" << endl;
	for (i = 0; i < 10; i++)
		cout << v[i] << " ";
	for (i = 0; i < 10; i++)
		a[i] = v[i];
	cout << endl;
	int selectvariable = select(a, 10, 0, 9, 4, "");
	cout <<"The median from this array is: "<< selectvariable;
	cout << endl;
	quickSelect(v, 10, 0, 9, "");
	cout << "This is The array sorted with quickselect:" << endl;
	for (i = 0; i < 10; i++)
		cout << v[i] << " ";
	
	cout << endl;
}

void generateChartsQuicksort(int number)
{
	const char* name;
	int n, i,a[MAX_VALUE];
		if (number == 0) {
			cout <<endl<< "Generating Average Case for QuickSort..."<<endl;
			name = "AverageQuicksortOperations";
			for (n = 100; n <= MAX_VALUE; n+=100) {
				for (i = 0; i < 5; i++) {
					FillRandomArray(a, n, 0, 10000, false, 0);
					quicksortRandom(a, n, 0, n - 1, name);
				}
				profiler.divideOperation(name,n,5);
			}
	}
		else
			if (number == 1) {
				cout <<endl<< "Generating Best Case for QuickSort..." << endl;
				name = "BestQuicksortOperations";
				for (n = 100; n <= MAX_VALUE; n += 100) {
					FillRandomArray(a, n, 0, 10000, false, 1);
					quicksortBest(a, n, 0, n - 1, name);
				}
			}
			else {
				cout <<endl<< "Generating Worst Case for QuickSort..." << endl;
				name = "WorstQuicksortOperations";
				for (n = 100; n <= MAX_VALUE; n += 100) {
					FillRandomArray(a, n, 0, 10000, false, 1);
					quicksort(a, n, 0, n - 1, name);
				}
			}
}
/*
My profiler didn't have a divideOperation so i made one. This is the code:
void divideOperation(const char* name, int size, int divider)
	{
		if (countersDisabled) return;
		try {
			opcountMap[name][size] /= divider;
		}
		catch (...) {
			OpcountMap::iterator it1 = opcountMap.find(name);
			if (it1 == opcountMap.end()) {
				opcountMap[name] = OpcountSequence();
			}
			OpcountSequence::iterator it2 = opcountMap[name].find(size);
			if (it2 == opcountMap[name].end()) {
				opcountMap[name][size] = 0;
			}
			opcountMap[name][size] /= divider;
		}

	}
*/
void generateAverageChartsHeapsort()
{
	const char* name;
	int n, i, a[MAX_VALUE];
		name = "AverageHeapSortOperations";
		cout << endl << "Generating Average Case for Heapsort..." << endl;
		for (n = 100; n <= MAX_VALUE; n =n+100) {
			for (i = 0; i < 5; i++) {
				FillRandomArray(a, n, 0, 10000, false, 0);
				bottomUpBuildHeap(a, n,n, name);
				heapSort(a,n,name);
			}
			profiler.divideOperation(name, n, 5);
		}
}

int main()
{
	profiler.disableCounters();
	exemplifyCorrectness();
	profiler.enableCounters();
	generateChartsQuicksort(0);
	generateChartsQuicksort(1);
	generateChartsQuicksort(2);
	generateAverageChartsHeapsort();
	profiler.createGroup("AverageCase", "AverageHeapSortOperations", "AverageQuicksortOperations");
	profiler.showReport();
	profiler.createGroup("QuickSort", "BestQuicksortOperations","AverageQuicksortOperations", "WorstQuicksortOperations");
	profiler.showReport();
	return 0;
}

